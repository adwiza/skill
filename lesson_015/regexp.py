import re

deep_ocean = '''oCeAn Marlin OcEaN oceAN ocEAN oCEAN OCEAN OCEAn OCEan OCean Ocean ocean oCeAn OcEaN oceAN ocEAN  
                OCEAN OCEAn OCEan OCean Ocean ocean oCeAn OcEaN oceAN ocEAN oCEAN OCEAN OCEAn OCEan OCean Ocean 
                ocean oCeAn OcEaN nemaa ocEAN oCEAN OCEAN OCEAn OCEan OCean nemoO ocean oCeAn OcEaN oceAN ocEAN 
                oCEAN OCEAN OCEAn OCEan OCean Ocean ocean oNeMa OcEaN oceAN ocEAN oCEAN OCEAN OCEAn OCEan OCean 
                Ocean ocean oCeAn OcEaN oceAN nenemo oCEAN OCEAN OCEAn OCEan OCean Ocean Nemo ocean oCeAn OcEaN 
                oceAN ocEAN oCEAN OCEAN OCEAn OCEan OCean Ocean ocean oCeAn OcEaN oceAN ocEAN oCEAN OCEAN OCEAn 
                OCEan OCean Ocean ocean  '''

nemo_patern = r'[Nn]em\w{,2}'  # r означает raw так называемыые сырые строки

# Основные функции первая из них match, которая обычно работает быстрее других функций поиска,
# т.к. ищет совпадения только сначала строки
matched_at_begin = re.match(nemo_patern, deep_ocean)
print(matched_at_begin)

# search() же производит поиск по всему тексту, но только до первого совпадения
matched = re.search(nemo_patern, deep_ocean)
print(f'Возвращается объект {matched} внутри которого содержится информация о совпадении')  # re.Match object
# Эту информацию можно извлечь следующими методами:
print(f'Подстрока, совпавшая с паттерном поиска {matched.group()}')  # type str
print(f'Индекс начала этой подстроки {matched.start()}')  # int

# Чтобы получить не только первый результат поиска мы можем воспользоваться итератором:
searching_iterator = re.finditer(nemo_patern, deep_ocean)
for matched in searching_iterator:
    # Сам по себе итератор будет возвращать объекты класса re.Match, как делал re.search
    print(f'Следующее совпадение {matched.group()}')  # str

# Чтоб найти все совпадения суцществует функция findall()

full_search = re.findall(nemo_patern, deep_ocean)
print(f'Список со всемми совпадениями паттерна, найденными во всем тексте {full_search}')  # list

final_matched = re.search('Nemo', deep_ocean)
print(f'Возвращение объекта с нужным совпадением {final_matched}')  # re.Match object
print(f'Уточнение индекса начала {final_matched.start()}')
print(f'Уточнение индекса конца {final_matched.end()}')
print(f'Длина фразы составит {final_matched.end() - final_matched.start()}')

# Функция sub позволяет не только осуществлять поиск, но и заменять найденное
transparent = re.sub(r'[Oo]\w{4}', '', deep_ocean)
print(f'Всё, что совпало с паттерном было заменено, осталось лишь {transparent}')

# Чтобы избавиться от пустот и оставить лишь наших рыбок, можно ннемного изменить шаблон
cleared = re.sub(r'[Oo]\w{4}\s+', '', deep_ocean)
print(f'Теперь в тексте остались лишь упоминания наших рыбок {cleared}')

# В дополнение к этой функции есть ещё одна, способная разделить как str.split() только
# в качестве разделителя используя заданную подстроку

separation = re.split('nemoO', cleared)
print(f'Список частей, между которыми был найден наш парттерн {separation}')  # 'list'

# Функция fullmatch() очень придирчива и возвращает результат только в случае полного совпадения
full_match = re.fullmatch('Marlin nemaa nemoO nenemo Nemo', cleared)
print(f'Полного совпадения найдено небыло {full_match}')  # None
full_match = re.fullmatch('Marlin nemaa nemoO nenemo Nemo ', cleared)
print(f'А вот теперь полное совпадение нашлось {full_match}')  # re.Match object

# INFO
###
# Особенности синтаксиса регулярных выражений

# OR в регулярных выражениях:
# в регулярных выражениях существует аналог питоновскому or, это символ '|'
# Он позволяет связать два шаблона в один, и если строка подойдёт хотя бы к одному из них, то она подойдёт
# этому новому шаблону.
# Так строка подходящая к шаблону А или к шаблону B подойдёт к шаблону A|B
# Например, отдельные овощи в тексте можно искать при помощи шаблона 'морковк|св[её]кл|картошк|редиск'

# Экранирование:
# В пайтоне, символ '\', который в обычных строках означает экранирование последующего символа.
# Т.к. в регулярных выражениях большинство символов используют '\' (\d,\w...)
# Нам придётся экранировать их каждый раз (\\d, \\w...)
# Чтобы избежать этого, перед строкой добавляют литерал r, который сообщает пайтону о том, что
# воспринимать '\' можно не как экранирующий символ.
# Однако!
# Среди специальных символов регулярных выражений есть те, которые не используют '\'
# Например '.'
# Но вдруг нам в тексте необходимо будет найти именно точку?
# Её придётся всё же экранировать слэшем '\.'

# В примере \(.*\) экранированы символы скобок.
# Если бы мы этого не сделали, скобки были бы приняты за специальные символы
# Которые означают группировку, суть которой мы рассмотрим позже


#
# Где можно отладить сложные регулярки?

# https://regex101.com/#python
# На этом сайте тоже есть отличный отладчик, который при этом учитывает синтаксис Питона + есть таблица с подсказками

# https://pythex.org/
# Самый простой из своих собратьев, для более уверенных пользователей


#
# Примеры

# Задача №1. Регистрационные знаки транспортных средств
# В России применяются регистрационные знаки нескольких видов.
# Общего в них то, что они состоят из цифр и букв. Причём используются только 12 букв кириллицы,
# имеющие графические аналоги в латинском алфавите — А, В, Е, К, М, Н, О, Р, С, Т, У и Х.

# У частных легковых автомобилях номера — это буква, три цифры, две буквы, затем две или три цифры с кодом региона.
# У такси — две буквы, три цифры, затем две или три цифры с кодом региона.
# Есть также и другие виды, но в этой задаче они не понадобятся.

# Задача в том, чтобы из перечня номеров найти номера частных автомобилей и номера такси:

license_plates = 'А578ВЕ777 ОР233787 К901МН666 СТ46599 СНИ2929П777 666АМР666'
# Напишем для каждого типа номеров свой шаблон:

private_template = r'[АВЕКМНОРСТУХ]\d{3}[АВЕКМНОРСТУХ]{2}\d{2,3}'
taxi_template = r'[АВЕКМНОРСТУХ]{2}\d{3}\d{2,3}'
private_cars = re.findall(private_template, license_plates)
taxi_cars = re.findall(taxi_template, license_plates)
print(f'Список номеров частных автомобилей {private_cars}')  # ['А578ВЕ777', 'К901МН666']
print(f'Список номеров такси {taxi_cars}')  # ['ОР233787', 'СТ46599']

# Задача №2.
# В многопользовательской онлайн игре введены новые правила нейминга. Вам, как самом ответственному блюстителю порядка,
# предстоит проверить всю базу данных, хранящую имена персонажей и "заморозить" тех персонажей, имена которых
# не проходят новые правила.
# Сами правила:
# Ограничение длины: от 3 до 17 символов
# Ограничение алфавита: все английские буквы, кроме xyz
# Первый символ обязательно должен быть буквой,
#   в остальных случаях допускаются четные цифры, подчеркивания, слэши.

gamers = ''' Dep3kuu_CaMypau41 3a_6a3ap_oTBeTb19 kypuTe_6aM6yk16 XoJIogHbIu_TankucT9  
BupTyaJlbHblu_BouH8 cepDuTblu_oxoTHuk6 TTaPHuLLIa6 Алмазик5  9I_ODun_Takou_KPyTou4 9l_aBTopuTeT4  
ABToMaT_kaJlaLLlHukoBa4 cepb3Hblu_4eJl4 cepb3Hblu_napHuLLIa4 kpyTa9l_6a3yka4 TIpocTo_He_xaMu4 ÊÐÌÑÕRÕG3  
3a_6a3ap_oTBe4al-o3 Cama_OTTacHocTb3 cepb3Hblu3 cJlblLLI_He_Tblkau3  M9TA3 MaJlo_BpeMeHu3  
ToHupoBka_no_kpyry3 '''

naming_rules = r'\s[a-wA-W][a-wA-W|\d*(02468)|\/_]{2,16}\s'

# Начало и конец заключены в \s чтобы отделить совпадения друг от друга
survivors = re.findall(naming_rules, gamers)
print(f'Список ников прошедших проверку {survivors}')

# Задача №3. Количество слов в тексте.
# В данной задаче словом будет считаться последовательность букв, внутри которой может быть дефис.
# В заданном тексте нужно найти количество слов(не учитывая союзы):

text_for_counting = '''– Они мясные.

– Мясные?

– Да. Они сделаны из мяса.

– Из мяса?!

– Ошибка исключена. Мы подобрали несколько экземпляров с разных частей планеты, доставили на борт нашего 
  корабля-разведчика и как следует протестировали. Они полностью из мяса.

– Но это невероятно! А как же радиосигналы? А послания к звездам?

– Для общения они используют радиоволны, но сигналы посылают не сами. Сигналы исходят от машин.

– Но кто строит эти машины? Вот с кем нужен контакт!

– Они и строят. О чем я тебе и толкую. Мясо делает машины.

– Что за чушь! Как может мясо изготовить машину? Ты хочешь, чтобы я поверил в мясо с памятью и чувствами?'''

rule_for_searching = '[а-яА-Я-]{4,}'
words = re.findall(rule_for_searching, text_for_counting)
print(f'Длина списка найденных совпадений {len(words)}')

# Группы в регулярных выражениях
mac_example = '''01:23:45:67:89:ab'''

mac_template_original = r'[0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-]['\
               '0-9a-fA-F]{2}'
mac_template_grouped = r'[0-9a-fA-F]{2}(?:[:-][0-9a-fA-F]{2}){5}'  # Всё, что в скобках - это группа, {5} сколько
# повторять
mac = re.findall(mac_template_grouped, mac_example)
print(f'Мак адрес, который был найден {mac}')

pattern = r'\s*([А-Яа-яЁё]+)(\d+)\s*'
pattern_all_symbols = r'(\W{3})(\s*)([А-Яа-яЁё]+)(\d+)(\s*)(\W{3})'
string = r'---   Опять45   ---'
matched = re.search(pattern_all_symbols, string)
print(f'Совпадение вернулось объектом {matched}')

print(f'Найдена подстройка >{matched[0]}< с позиции {matched.start(0)} до {matched.end(0)}')
print(f'Найдена подстройка >{matched[1]}< с позиции {matched.start(1)} до {matched.end(1)}')
print(f'Найдена подстройка >{matched[2]}< с позиции {matched.start(2)} до {matched.end(2)}')
print(f'Найдена подстройка >{matched[3]}< с позиции {matched.start(3)} до {matched.end(3)}')
print(f'Найдена подстройка >{matched[4]}< с позиции {matched.start(4)} до {matched.end(4)}')
print(f'Найдена подстройка >{matched[5]}< с позиции {matched.start(5)} до {matched.end(5)}')
print(f'Найдена подстройка >{matched[6]}< с позиции {matched.start(6)} до {matched.end(6)}')

# Задача №4.
# Вовочка подготовил одно очень важное письмо, но везде указал неправильное время.
# Поэтому нужно заменить все вхождения времени на строку (TBD).
# Время — это строка вида HH:MM:SS или HH:MM, в которой HH — число от 00 до 23, а MM и SS — число от 00 до 59.

letter = '''Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!'''

# Если первая цифра "0" или "1", вторая любая, если первая цифра "2" то вторая от "0" до "3", т.к. 0-23 часа
# Со вторым сегментов времени всё понятно, 0 - 5 т.к. 0 - 59 минут и секунд
time_rule = r'([01]\d|2[0-3])(:[0-5][0-9]){1,2}'
time_swap = re.sub(time_rule, 'TDB', letter)
print(f'Письмо Вовочки теперь выглядит так {time_swap}')
